function C = quad2dcov(varargin)
% Theoretical noise covariance structure corresponding to a 2D quadratic function.
%
% Input arguments:
% sigma_x, sigma_y:
%    vector of noise covariance components
% -- OR --
% phi:
%    the noise direction in the range [0, 1/2 \pi]
%
% x, y:
%    vector of observed data

% Copyright 2008-2009 Levente Hunyadi

narginchk(3,4);
switch nargin
    case 3
        phi = varargin{1};
        [x,y] = quad2dcov_data(varargin{2:3});
        
        sx = cos(phi);
        sy = sin(phi);
        C = zeros(6,6,3);
        C(:,:,1) = ...
        [ 0, 0, 0, 0, 0, 0 ...
        ; 0, 0, 0, 0, 0, 0 ...
        ; 0, 0, 0, 0, 0, 0 ...
        ; 0, 0, 0, 0, 0, 0 ...
        ; 0, 0, 0, 0, 0, 0 ...
        ; 0, 0, 0, 0, 0, 0 ...
        ];
        C(:,:,2) = ...
        [            mean(6.*sx.^2.*x.^2),            mean(3.*sx.^2.*x.*y), mean(sx.^2.*y.^2 + sy.^2.*x.^2), mean(3.*sx.^2.*x),    mean(sx.^2.*y), mean(sx.^2) ...
        ;            mean(3.*sx.^2.*x.*y), mean(sx.^2.*y.^2 + sy.^2.*x.^2),            mean(3.*sy.^2.*x.*y),    mean(sx.^2.*y),    mean(sy.^2.*x),           0 ...
        ; mean(sx.^2.*y.^2 + sy.^2.*x.^2),            mean(3.*sy.^2.*x.*y),            mean(6.*sy.^2.*y.^2),    mean(sy.^2.*x), mean(3.*sy.^2.*y), mean(sy.^2) ...
        ;               mean(3.*sx.^2.*x),                  mean(sx.^2.*y),                  mean(sy.^2.*x),       mean(sx.^2),                 0,           0 ...
        ;                  mean(sx.^2.*y),                  mean(sy.^2.*x),               mean(3.*sy.^2.*y),                 0,       mean(sy.^2),           0 ...
        ;                     mean(sx.^2),                               0,                     mean(sy.^2),                 0,                 0,           0 ...
        ];
        C(:,:,3) = ...
        [     mean(-3.*sx.^4),                   0, mean(-sx.^2.*sy.^2), 0, 0, 0 ...
        ;                   0, mean(-sx.^2.*sy.^2),                   0, 0, 0, 0 ...
        ; mean(-sx.^2.*sy.^2),                   0,     mean(-3.*sy.^4), 0, 0, 0 ...
        ;                   0,                   0,                   0, 0, 0, 0 ...
        ;                   0,                   0,                   0, 0, 0, 0 ...
        ;                   0,                   0,                   0, 0, 0, 0 ...
        ];
    case 4
        sigma_x = varargin{1};
        sigma_y = varargin{2};
        [x,y] = quad2dcov_data(varargin{3:4});

        C = ...
        [                          mean(-3.*sigma_x.^4 + 6.*sigma_x.^2.*x.^2),                                           mean(3.*sigma_x.^2.*x.*y), mean(-sigma_x.^2.*sigma_y.^2 + sigma_x.^2.*y.^2 + sigma_y.^2.*x.^2), mean(3.*sigma_x.^2.*x),    mean(sigma_x.^2.*y), mean(sigma_x.^2) ...
        ;                                           mean(3.*sigma_x.^2.*x.*y), mean(-sigma_x.^2.*sigma_y.^2 + sigma_x.^2.*y.^2 + sigma_y.^2.*x.^2),                                           mean(3.*sigma_y.^2.*x.*y),    mean(sigma_x.^2.*y),    mean(sigma_y.^2.*x),                0 ...
        ; mean(-sigma_x.^2.*sigma_y.^2 + sigma_x.^2.*y.^2 + sigma_y.^2.*x.^2),                                           mean(3.*sigma_y.^2.*x.*y),                          mean(-3.*sigma_y.^4 + 6.*sigma_y.^2.*y.^2),    mean(sigma_y.^2.*x), mean(3.*sigma_y.^2.*y), mean(sigma_y.^2) ...
        ;                                              mean(3.*sigma_x.^2.*x),                                                 mean(sigma_x.^2.*y),                                                 mean(sigma_y.^2.*x),       mean(sigma_x.^2),                      0,                0 ...
        ;                                                 mean(sigma_x.^2.*y),                                                 mean(sigma_y.^2.*x),                                              mean(3.*sigma_y.^2.*y),                      0,       mean(sigma_y.^2),                0 ...
        ;                                                    mean(sigma_x.^2),                                                                   0,                                                    mean(sigma_y.^2),                      0,                      0,                0 ...
        ];
end

function [x,y] = quad2dcov_data(x,y)

validateattributes(x, {'numeric'}, {'real','nonempty','vector'});
validateattributes(y, {'numeric'}, {'real','nonempty','vector'});
assert(numel(x) == numel(y), ...
    'quad2dcov:DimensionMismatch', 'Data vectors x and y must have the same number of elements.');
x = x(:);
y = y(:);